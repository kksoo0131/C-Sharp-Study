<h1>정렬</h1>

데이터를 특정한 기준에 따라서 순서대로 나열하는 것, 이진 탐색 (Binary Search)를 하기 위한 전처리 과정이기도 함

정렬 알고리즘은 굉장히 다양하지만 이 중에서 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬 등이 많이 사용된다.

<h2>선택 정렬</h2>

가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 

그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 정렬 방법

시간 복잡도는 O(N^2)이다.


<h2>삽입 정렬</h2>

특정한 데이터를 적절한 위치에 삽입하는 정렬 방법으로

첫 번쨰 데이터를 정렬 되어 있다고 판단하고 기준으로 삼아서 두 번쨰 데이터부터 어떤 위치로 들어갈지 판단한다.

시간 복잡도는 O(N^2)이지만, 현재 리스트가 거의 "정렬 되어있는 상태"라면 최선의 경우 O(N)의 시간 복잡도를 가진다.


<h2>퀵 정렬</h2>

퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 쿄환한 후 리스트를 반으로 나누는 방식으로 동작 한다.

이때 기준을 "피벗"이라고 하고 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설장할 것인지 미리 명시해야 한다.

피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분한다.

ex 1. 호어 분할 방식 : 리스트에서 첫 번째 데이터를 피벗으로 정한다.


퀵 정렬의 평균 시간 복잡도는 O(N logN) 이지만, 최악의 경우 시간 복잡도는 O(N^2)이다.
 
퀵 정렬은 데이터가 무작위로 있을때 빠르게 동작할 확률이 높고, 데이터가 이미 정렬되어 있는 경우에는 매우 느리게 동작한다.


퀵 정렬을 기반으로 작성된 정렬 라이브러리를 제공하는 프로그래밍 언어들은 보통 

최악의 경우에도 O(N logN)의 시간 복잡도가 되는것을 보장하기 위해서 피벗값을 설정할때 추가적인 로직을 더해준다.


<h2>계수 정렬</h2>

특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘으로 "데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때"만 사용할 수 있다.

일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.

계수 정렬을 이용할 때는 "모든 범위를 담을 수 잇는 크기의 리스트를 선언해야 한다" 

ex) 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이라면 크기가 1,000,001 인 리스트를 초기화해야 한다. (0 ~ 1,000,000까지는 총 1,000,001개의 수가 존재)

계수 정렬은 "비교 기반의 정렬 알고리즘)이 아니다. 

1. 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.

2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

3. 결과적으로 리스트에는 각 데이터가 몇 번 등장했는지 횟수가 기록된다.

시간 복잡도는 O(N+K)이지만, 때에 따라서 공간 복잡도가 심각하게 비효율적이다.

<h2>문제 유형</h2>

1. 정렬 라이브러리를 사용하는 문제

2. 정렬 알고리즘의 원리에 대해 물어보는 문제

3. 더 빠른 정렬이 필요한 문제
